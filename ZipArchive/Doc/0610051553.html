<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <title>ZipArchive:
        Segmented Archives: Splitting and Spanning
    </title>
    <link href="articles.css" rel="stylesheet" type="text/css" />
    <style type="text/css">
    body
    {
    	font-family: verdana, arial, helvetica, sans-serif;
    }
</style>
</head>
<body>
    <div class="kbabody">
        <div class="kbatitle">
            Segmented Archives: Splitting and Spanning
        </div>
        <div class="kbaappliesto">
            Applies To: <strong>All</strong>
        </div>
        <div class="kbaindex">
            <ul class="kbaindex">

<li><a class="linkindex" href="#general">Introduction</a>
<ul class="kbaindex">
<li><a class="linkindex" href="#conv">Conversion Between Split and Spanned Archives</a></li>
<li><a class="linkindex" href="#limits">Limits in Number of Volumes</a></li>
</ul>
</li>
<li><a class="linkindex" href="#split">Splitting: All Volumes in One Folder</a>
<ul class="kbaindex">
<li><a class="linkindex" href="#split-callback">Using Callback with Split Archives</a></li>
</ul>
</li>
<li><a class="linkindex" href="#span">Spanning: Use on Removable Media</a>
<ul class="kbaindex">
<li><a class="linkindex" href="#spanlast">Detecting the Last Disk in a Drive</a></li>
</ul>
</li>
<li><a class="linkindex" href="#callbacks">Callbacks Called</a></li>
<li><a class="linkindex" href="#api">See Also API Calls</a></li></ul>

        </div>
        <div class="kbacontents">
            
        <h2 id="general" name="general" class="kb">
            Introduction</h2>
        The ZipArchive Library can create segmented archives using two methods: splitting
        and spanning. The internal structure of archives created in both ways is the same;
        the difference in use is summarized below:<br />
        <br />
        <div style="text-align: center;">
            <table border="0" cellpadding="3" cellspacing="0" class="kb">
                <tr class="kbheader">
                    <td>
                    </td>
                    <td>
                        Splitting</td>
                    <td>
                        Spanning</td>
                </tr>
                <tr>
                    <td>
                        Destination media</td>
                    <td>
                        not limited to any</td>
                    <td>
                        removable</td>
                </tr>
                <tr>
                    <td>
                        Archive Structure</td>
                    <td>
                        splits into volumes<br />
                        (usually in the same folder)</td>
                    <td>
                        spans multiple disks</td>
                </tr>
                <tr>
                    <td>
                        Naming</td>
                    <td>
                        extension is based on the volume number,<br />
                        the&nbsp;last&nbsp;volume's&nbsp;extension&nbsp;is&nbsp;"zip"
                        <br />
                        (it is possible to implement a custom naming scheme)</td>
                    <td>
                        each volume has the same name</td>
                </tr>
                <tr>
                    <td>
                        Single Volume Size</td>
                    <td>
                        declared by the user when creating an archive</td>
                    <td>
                        auto-detected from the free space on the current disk</td>
                </tr>
                <tr>
                    <td>
                        Callback</td>
                    <td>
                        not needed, but possible</td>
                    <td>
                        needed for changing volume</td>
                </tr>
            </table>
        </div>
        <ul>
            <li>Splitting and spanning are compatible with PKZIP and WinZip.</li>
            <li>To set a callback object, use the <a class="linkapi" href="./classCZipArchive.html#7f0aeb9a7368afd0689149485bd7ca5b">CZipArchive::SetSegmCallback()</a>
                method. To differentiate between callbacks set for spanned and split archive, use
                the second argument of this method.</li>
            <li>The class of the callback object must be derived from the <a class="linkapi" href="./structCZipSegmCallback.html">CZipSegmCallback</a> class.</li>
            <li>The ZipArchive Library does not allow direct modifications of existing segmented
                archives. However you can apply changes to an existing segmented archive by creating
                a new one and copying data from the old one using one of the <code>CZipArchive::GetFromArchive()</code>
                methods. These methods will copy compressed data from the old archive without decompression.
                You can find some more information here: <a class="linkkb" href="0610231446.html#get">Compressing Data</a>.</li>
            <li>The <code>CZipArchive</code> class uses a write buffer to optimize the speed of
                write operations. You can change its size with the <a class="linkapi" href="./classCZipArchive.html#be06c912f3dbacfe3d327d7c7a2d0e88">CZipArchive::SetAdvanced()</a>
                method (set the first argument). While creating a segmented archive, set the size
                of the buffer to the maximum size of the volume for the best performance.</li>
            <li>To determine the total number of volumes in an archive, first request the central
                directory information using the <a class="linkapi" href="./classCZipArchive.html#fbf6eb8ce378ec0812f0ccb7827e8e79">CZipArchive::GetCentralDirInfo()</a>
                method. The total number of volumes can be then obtained by adding one to the <a class="linkapi" href="./structCZipCentralDir_1_1CInfo.html#358ccf93954d97ad44ed35f4bbf1c704">CZipCentralDir::CInfo::m_uLastVolume</a> value, as illustrated
                in the sample code below.
                <br />
                <div class="codetitle">Sample Code</div><pre class="fragment">    CZipArchive zip;    
    zip.Open(_T(<span class="stringliteral">"C:\\Temp\\test.zip"</span>));
    CZipCentralDir::CInfo info;
    zip.GetCentralDirInfo(info);
    ZIP_VOLUME_TYPE uTotalSegments = info.m_uLastVolume + 1;
    <span class="comment">// ...</span>
    zip.Close();    
</pre>
            </li>
        </ul>
        <h3 id="conv" name="conv" class="kb">
            Conversion Between Split and Spanned Archives</h3>
        To convert between split and spanned archives, it is enough to change the names
        of volumes and copy the volumes to appropriate locations.
        <ul>
            <li>To convert a spanned archive to a split archive, copy all the volumes into one location
                and rename their extensions according to the <code>printf</code> function format
                using the pattern: <code>z%.2d</code>. For the volumes numbers greater than 99 this
                pattern becomes <code>z%d</code>. Use the one-based volumes number as an argument.
                Use the "zip" extension for the last volume. This way the volumes are
                names this way:
                <ul class="non">
                    <li>name.z01</li>
                    <li>name.z02</li>
                    <li>...</li>
                    <li>name.z100</li>
                    <li>...</li>
                    <li>name.zip</li>
                </ul>
                <br />
            </li>
            <li>To convert a split archive to a spanned archive, copy each volume to a separate
                removable media, giving it the "zip" extension. You also should name each disk with
                the appropriate label starting from <span class="nowrap">"pkback# 001"</span>
                (note the space between '#' and '0'). </li>
        </ul>
        <h3 id="limits" name="limits" class="kb">
            Limits in Number of Volumes</h3>
        In the standard zip format, the number of volumes is limited to:
        <br />
        <br />
        <div style="text-align: center;">
            <table border="0" cellpadding="3" cellspacing="0" class="kb">
                <tr class="kbheader">
                    <td>
                    </td>
                    <td>
                        Splitting</td>
                    <td>
                        Spanning</td>
                </tr>
                <tr>
                    <td>
                        Standard Zip Format</td>
                    <td>
                        65,535</td>
                    <td>
                        999</td>
                </tr>
                <tr>
                    <td>
                        Zip64 Format</td>
                    <td>
                        <span class="nowrap">4,294,967,295 - 1</span></td>
                    <td>
                        <span class="nowrap">4,294,967,295 - 1</span></td>
                </tr>
            </table>
        </div>
        <br />
        For more information on the Zip64 format, see <a class="linkkb" href="0610051629.html">Zip64 Format: Crossing the Limits of File Sizes and Number of Files and Segments</a>.
        <h2 id="split" name="split" class="kb">
            Splitting: All Volumes in One Folder</h2>
        The volumes of a split archive are usually located in the same folder. You need
        to specify a size of a single volume when creating a split archive. Internal zip
        structures such as file headers, are not split across volumes. This may result in
        a volume size being slightly smaller from the declared size, when the structure
        could not fit entirely into the current volume and it was stored in the next volume.
        If the declared volume size is too small to hold an entire internal structure, this
        particular volume will be enlarged. Generally you should not use values less than
        64KB for volumes sizes.
        <p />
        Under Linux, when you are opening an existing split archive, set <code>uVolumeSize</code>
        to a value different from <code>0</code> when calling the <a class="linkapi" href="./classCZipArchive.html#3d3ae4cf7f48f19120924ebe1e4b7386">CZipArchive::Open(LPCTSTR)</a> method. This is caused by the lack of the implementation
        of <a class="linkapi" href="./namespaceZipPlatform.html#fd9f8021d83764be0fb27ea940222796">ZipPlatform::IsDriveRemovable()</a> and the device containing
        the archive is always assumed to be removable.
        <div class="codetitle">Sample Code</div><pre class="fragment">    LPCTSTR zipFileName = _T(<span class="stringliteral">"C:\\Temp\\test.zip"</span>);
    CZipArchive zip;    
    <span class="comment">// specify the segment size to be 1MB</span>
    zip.Open(zipFileName, CZipArchive::zipCreateSegm, 1024 * 1024);    
    zip.AddNewFile(_T(<span class="stringliteral">"C:\\Temp\\big.dat"</span>));
    zip.Close();    
    <span class="comment">// the segmentation type will be auto-detected as splitting</span>
    <span class="comment">// (the archive is on a non-removable device)</span>
    zip.Open(zipFileName);
    <span class="comment">// under Linux, call instead: zip.Open(zipFileName, CZipArchive::zipOpen, 1);</span>
    zip.ExtractFile(0, _T(<span class="stringliteral">"C:\\Temp"</span>), <span class="keyword">false</span>, _T(<span class="stringliteral">"big.ext"</span>));
    zip.Close();
</pre>
        <h3 id="split-callback" name="split-callback" class="kb">
            Using Callback with Split Archives</h3>
        Using callback with split archives is not necessary, but possible. This is useful
        when you need to implement a custom volumes' naming scheme or to have the possibility
        to prompt a user for a location of a volume, when it was not found.
        <p />
        When the callback is set, the <a class="linkapi" href="./structCZipCallback.html#27652d72804471adabcdcc18274bbbf5">CZipCallback::Callback</a>
        method will be called every time a volume change occurs.
        <ul>
            <li>The reason for calling the callback is stored in <a class="linkapi" href="./structCZipSegmCallback.html#58447cfa3f1e7b3d3343271cf2509812">CZipSegmCallback::m_iCode</a>
                and takes one of the <a class="linkapi" href="./structCZipSegmCallback.html#6621231bf0bfde4a9646f810a01a3901">CZipSegmCallback::SegmCodes</a> values.</li>
            <li>You can change the filename and path of the current volume by modifying the <a class="linkapi" href="./structCZipCallback.html#132345e5a62fd08a249cabc01383af6f">CZipCallback::m_szExternalFile</a> variable. When the callback
                is called, this variable holds the full path to the volume file as expected by the
                library, but you can change it and the library will create the volume file under
                a new name or location.</li>
            <li>The number of the disk needed for reading or writing is stored in
                <br />
                <a class="linkapi" href="./structCZipSegmCallback.html#bbf4160b8992b7694cc7a686693ed452">CZipSegmCallback::m_uVolumeNeeded</a>.</li>
            <li>To abort the archive processing, return <code>false</code> from this method. A <a class="linkapi" href="./classCZipException.html">CZipException</a> will be thrown with the <a class="linkapi" href="./classCZipException.html#a4f3fc7c792e57a0a6881b6ea48725afa9beec1f47e84433e4e60b98e922f6d0">CZipException::aborted</a>
                code.</li>
            <li>The value of the <code>uProgress</code> parameter is set to <code>0</code> apart
                from the time when the callback is called for the last volume. It is then set to
                <span class="preproc">ZIP_SPLIT_LAST_VOLUME</span>.</li>
            <li>When creating a split archive, the callback is called twice for the last volume.
                <ul class="dec">
                    <li>The first time it is called when the library doesn't know yet that the current volume
                        is the last volume and the value of the <code>uProgress</code> parameter is set
                        to <code>0</code>.</li>
                    <li>The second time it is called when the library already knows that the current volume
                        is the last volume and the value of the <code>uProgress</code> parameter is set
                        to <span class="preproc">ZIP_SPLIT_LAST_VOLUME</span>.</li>
                </ul>
            </li>
        </ul>
        <div class="codetitle">Sample Code</div><pre class="fragment"><span class="keyword">class </span>CSplitCallback : <span class="keyword">public</span> CZipSegmCallback
{
    <span class="keywordtype">bool</span> Callback(ZIP_SIZE_TYPE uProgress)
    {
        <span class="keywordflow">switch</span> (m_iCode)
        {
            <span class="keywordflow">case</span> scVolumeNeededForRead:
            <span class="keywordflow">case</span> scVolumeNeededForWrite:
            <span class="keywordflow">case</span> scFileNameDuplicated:
            {
                <span class="keywordflow">if</span> (m_iCode == scFileNameDuplicated)
                {
                    <span class="comment">// it can happen only when writing an archive;</span>
                    <span class="comment">// delete the file, if it already exists</span>

                    <span class="comment">// it would be more optimal to check for the file existence</span>
                    <span class="comment">// when scVolumeNeededForWrite was called to save one turn, but </span>
                    <span class="comment">// this code is provided to illustrate the possible events</span>
                    <span class="keywordflow">if</span> (!ZipPlatform::RemoveFile(m_szExternalFile))
                    {
                        _tprintf(_T(<span class="stringliteral">"Removing of the existing file failed."</span>));
                        <span class="keywordflow">return</span> <span class="keyword">false</span>;
                    }
                }

                <span class="comment">// implement a custom naming scheme;</span>
                <span class="comment">// alternatively we could prompt the user to enter </span>
                <span class="comment">// the new path or filename of the volume        </span>

                CZipPathComponent zpc(m_szExternalFile);        
                <span class="keywordflow">if</span> (uProgress == ZIP_SPLIT_LAST_VOLUME)
                    <span class="comment">// use the regular extension for the last volume</span>
                    zpc.SetExtension(_T(<span class="stringliteral">"zip"</span>));
                <span class="keywordflow">else</span>
                {
                    <span class="comment">// use "vol????" extension for other volumes</span>
                    CZipString szExt;
                    DWORD vol = m_uVolumeNeeded;
                    szExt.Format(_T(<span class="stringliteral">"vol%.4u"</span>), vol);
                    zpc.SetExtension(szExt);
                }

                <span class="comment">// modify the file path to be used for archive volume</span>
                m_szExternalFile = zpc.GetFullPath();
                <span class="keywordflow">break</span>;
            }
            <span class="keywordflow">case</span> scFileCreationFailure:
                _tprintf(_T(<span class="stringliteral">"Could not create the file. \</span>
<span class="stringliteral">Check, if you have write permissions to the given location.\r\n"</span>));             
                <span class="comment">// abort processing</span>
                <span class="keywordflow">return</span> <span class="keyword">false</span>;    
            <span class="keywordflow">case</span> scFileNotFound:
                _tprintf(_T(<span class="stringliteral">"The given volume could not be found.\r\n"</span>));             
                <span class="comment">// abort processing, although we could ask a user here</span>
                <span class="comment">// to provide the location of our volume</span>
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
            <span class="keywordflow">default</span>:
                _tprintf(_T(<span class="stringliteral">"An unexpected code detected.\r\n"</span>));
                <span class="comment">// abort processing</span>
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
            <span class="keywordflow">break</span>;
        }         
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
};

<span class="keywordtype">void</span> SplittingWithCallback()
{
    <span class="comment">// this code is identical to the previous sample with the </span>
    <span class="comment">// exception of setting the callback</span>
    LPCTSTR zipFileName = _T(<span class="stringliteral">"C:\\Temp\\test.zip"</span>);
    CZipArchive zip;    
    CSplitCallback callback;
    <span class="comment">// set the callback before creating the archive;</span>
    <span class="comment">// note the second parameter value</span>
    zip.SetSegmCallback(&amp;callback, CZipArchive::scSplit);
    zip.Open(zipFileName, CZipArchive::zipCreateSegm, 1024 * 1024);    
    zip.AddNewFile(_T(<span class="stringliteral">"C:\\Temp\\big.dat"</span>));
    zip.Close();    
    zip.Open(zipFileName);
    <span class="comment">// under Linux, call instead: zip.Open(zipFileName, CZipArchive::zipOpen, 1);</span>
    zip.ExtractFile(0, _T(<span class="stringliteral">"C:\\Temp"</span>), <span class="keyword">false</span>, _T(<span class="stringliteral">"big.ext"</span>));
    zip.Close();
}
</pre>
        <h2 id="span" name="span" class="kb">
            Spanning: Use on Removable Media</h2>
        <ul>
            <li>A spanned archive is located on removable media and you need to specify a callback
                object (with the <a class="linkapi" href="./classCZipArchive.html#7f0aeb9a7368afd0689149485bd7ca5b">CZipArchive::SetSegmCallback()</a> method).
                Setting the callback object is needed for creation as well as for extraction of
                spanned archives.</li>
            <li>The <a class="linkapi" href="./structCZipCallback.html#27652d72804471adabcdcc18274bbbf5">CZipCallback::Callback</a> method will be called every
                time a disk change is needed.
                <ul>
                    <li>The reason for calling the callback is stored in <a class="linkapi" href="./structCZipSegmCallback.html#58447cfa3f1e7b3d3343271cf2509812">CZipSegmCallback::m_iCode</a>
                        and takes one of the <a class="linkapi" href="./structCZipSegmCallback.html#6621231bf0bfde4a9646f810a01a3901">CZipSegmCallback::SegmCodes</a> values.</li>
                    <li>The value of the <code>uProgress</code> parameter of the callback method is the
                        minimum number of free bytes required on the disk. </li>
                    <li>The number of the disk needed for reading or writing is stored in
                        <br />
                        <a class="linkapi" href="./structCZipSegmCallback.html#bbf4160b8992b7694cc7a686693ed452">CZipSegmCallback::m_uVolumeNeeded</a>.</li>
                    <li>To abort the archive processing, return <code>false</code> from this method. A <a class="linkapi" href="./classCZipException.html">CZipException</a> will be thrown with the <a class="linkapi" href="./classCZipException.html#a4f3fc7c792e57a0a6881b6ea48725afa9beec1f47e84433e4e60b98e922f6d0">CZipException::aborted</a>
                        code.</li>
                </ul>
            </li>
        </ul>
        <div class="codetitle">Sample Code</div><pre class="fragment"><span class="preprocessor">#include &lt;conio.h&gt;</span> <span class="comment">// for _getch()</span>

<span class="keyword">class </span>CSpanCallback : <span class="keyword">public</span> CZipSegmCallback
{
    <span class="keywordtype">bool</span> Callback(ZIP_SIZE_TYPE uProgress)
    {
        <span class="keywordflow">switch</span> (m_iCode)
        {
            <span class="keywordflow">case</span> scVolumeNeededForRead:
            <span class="keywordflow">case</span> scVolumeNeededForWrite:
                _tprintf(_T(<span class="stringliteral">"Insert the disk number %d\r\n"</span>), m_uVolumeNeeded);
                <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> scFileNameDuplicated:
                _tprintf(_T(<span class="stringliteral">"The file with the given name already \</span>
<span class="stringliteral">exists on the disk.\r\n"</span>));
                <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> scCannotSetVolLabel:
                _tprintf(_T(<span class="stringliteral">"Cannot set the disk volume label. \</span>
<span class="stringliteral">Check if the disk is not write-protected.\r\n"</span>));
                <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> scFileCreationFailure:
                _tprintf(_T(<span class="stringliteral">"Could not create file. \</span>
<span class="stringliteral">Check if the disk is not write-protected.\r\n"</span>));             
                <span class="keywordflow">break</span>;                
            <span class="keywordflow">default</span>:
                _tprintf(_T(<span class="stringliteral">"An unexpected code detected.\r\n"</span>));
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
            <span class="keywordflow">break</span>;
        }         
        _getch();
        _tprintf(_T(<span class="stringliteral">"...\r\n"</span>));
        <span class="comment">// return false here to abort processing</span>
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
};

<span class="keywordtype">void</span> Spanning()
{    
    LPCTSTR zipFileName = _T(<span class="stringliteral">"a:\\test.zip"</span>);
    CZipArchive zip;    
    CSpanCallback callback;
    <span class="comment">// set the callback before creating the archive</span>
    zip.SetSegmCallback(&amp;callback);
    zip.Open(zipFileName, CZipArchive::zipCreateSegm, ZIP_AUTODETECT_VOLUME_SIZE);    
    zip.AddNewFile(_T(<span class="stringliteral">"C:\\Temp\\big.dat"</span>));
    zip.Close();    
    <span class="comment">// the callback is already set</span>
    <span class="comment">// and the segmentation type will be auto-detected as spanning</span>
    <span class="comment">// (the archive is on a removable device)</span>
    zip.Open(zipFileName);
    zip.ExtractFile(0, _T(<span class="stringliteral">"C:\\Temp"</span>), <span class="keyword">false</span>, _T(<span class="stringliteral">"big.ext"</span>));
    zip.Close();
}
</pre>
        <h3 id="spanlast" name="spanlast" class="kb">
            Detecting the Last Disk in a Drive</h3>
        When extracting a spanned archive, you need to insert the last disk into the drive
        before opening the archive. The central directory written on it and the extraction
        starts from reading the central directory. There is no simple way to detect, if
        the right disk is in the drive, but the ZipArchive Library throws the <a class="linkapi" href="./classCZipException.html">CZipException</a> with the <a class="linkapi" href="./classCZipException.html#a4f3fc7c792e57a0a6881b6ea48725af62c9a10984629c00e661ef7e218dc1b0">CZipException::cdirNotFound</a>
        code, when the archive you are trying to open does not have the central directory.
        In case of a spanned archive, it may mean that the user has not inserted the last
        disk into the drive. You can catch this exception and keep prompting the user for
        the right disk until the archive is successfully opened.
        <h2 id="callbacks" name="callbacks" class="kb">
            Callbacks Called</h2>
        While processing a segmented archive the following callbacks that are called are
        the most important:
        <ul class="non">
            <li><a class="linkapi" href="./structCZipActionCallback.html#987550875690c39c4278cc65e4f117344e48c2f0d8f6bd1de700e56927c55de8">CZipActionCallback::cbAdd</a></li>
            <li><a class="linkapi" href="./structCZipActionCallback.html#987550875690c39c4278cc65e4f1173410ea05b0de77ed3df7719cd321c0d22f">CZipActionCallback::cbAddTmp</a></li>
            <li><a class="linkapi" href="./structCZipActionCallback.html#987550875690c39c4278cc65e4f11734a4792345795d95ef78e25826b893b58c">CZipActionCallback::cbAddStore</a></li>
            <li><a class="linkapi" href="./structCZipActionCallback.html#987550875690c39c4278cc65e4f117346b92922ec8ce88d0ad043878fb096d97">CZipActionCallback::cbExtract</a></li>
            <li><a class="linkapi" href="./structCZipActionCallback.html#987550875690c39c4278cc65e4f1173493b49690cff50f46013d99a76357ef78">CZipActionCallback::cbSave</a></li>
        </ul>
        To read more about using callback objects, see <a class="linkkb" href="0610231200.html">Progress Notifications: Using Callback Objects</a>.
        <h2 id="api" name="api" class="kb">
            See Also API Calls</h2>
        <ul class="non">
            <li><a class="linkapi" href="./classCZipArchive.html#3d3ae4cf7f48f19120924ebe1e4b7386">CZipArchive::Open(LPCTSTR)</a></li>
            <li><a class="linkapi" href="./classCZipArchive.html#7f0aeb9a7368afd0689149485bd7ca5b">CZipArchive::SetSegmCallback()</a></li>
            <li><a class="linkapi" href="./structCZipSegmCallback.html">CZipSegmCallback</a></li>
            <li><a class="linkapi" href="./classCZipArchive.html#7af74c5c55446c9d9ce509b7d92ab182">CZipArchive::GetSegmMode()</a></li>
            <li><a class="linkapi" href="./classCZipArchive.html#be06c912f3dbacfe3d327d7c7a2d0e88">CZipArchive::SetAdvanced()</a></li>
        </ul>
    
        </div>
        <div class="kbafooter">
            <strong>Article ID:&nbsp;0610051553</strong>
        </div>
    </div>
   <div style="font-size:11px; text-align:center;border-top:solid 1px gray;width:400px;margin:10px auto 5px auto;color:gray">
Copyright &copy;&nbsp;2000 - 2007 Artpol Software - Tadeusz Dracz
</div>
</body>
</html>
